[{"content":" ","date":"19 December 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/algo-trading/","section":"Tags","summary":"","title":"Algo-Trading","type":"tags"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/backtesting/","section":"Tags","summary":"","title":"Backtesting","type":"tags"},{"content":"Welcome to the first entry in a multi-part series where I document the journey of building a fully automated, production-grade cryptocurrency trading system from scratch using R, primarily focussed on BTC-AUD.\nBefore we write a single line of execution code or connect to an exchange API, we have to answer the most important question in quantitative finance: Does this strategy actually work, or is it just a fluke of historical noise?\nThe Philosophy: Survival of the Fittest # Many beginners pick one strategy (like an SMA Cross), run it on one year of Bitcoin data, and if the \u0026ldquo;line goes up,\u0026rdquo; they go live. This is a recipe for disaster.\nIn this project, we utilise a Monte Carlo Windowing approach. If you find the term \u0026ldquo;Monte Carlo\u0026rdquo; a bit too \u0026ldquo;Wall Street,\u0026rdquo; think of it this way:\nImagine 1,000 different traders all trading BTC-AUD, with a starting initial of $1,000 each. Each trader starts at a completely different point in time and trades for a different length of duration. Now, imagine every single one of those 1,000 traders is testing all 8 of our algorithms across every possible stop-loss setting.\nBy doing this, we aren\u0026rsquo;t just testing if a strategy works \u0026ldquo;on average\u0026rdquo;; we are testing if it survives in the hands of the \u0026ldquo;unlucky\u0026rdquo; trader who started right before a crash, or the \u0026ldquo;impatient\u0026rdquo; trader who only stayed in the market for three months. This allows us to see the distribution of outcomes across thousands of different market regimes.\nThe Candidates: The Algorithms Under the Microscope # To find our \u0026ldquo;Champion\u0026rdquo; strategy, we are testing a diverse range of algorithmic approaches. Each is designed to handle price action differently, from simple trend following to complex volatility-normalised momentum.\nBuy and Hold (The Benchmark)\nThis is our baseline. It involves buying the asset at the start of the window and holding it until the end, regardless of price fluctuations. Any strategy we build must significantly outperform this after accounting for risk and fees to be considered viable.\nSMA (The Simple Trend Follower)\nThe Simple Moving Average (SMA) is a pure trend-following strategy.\nThe Signal: We buy when the price moves above the SMA and sell when it drops below. The Goal: Detect trend direction changes early. It performs beautifully in trending markets but can suffer from \u0026ldquo;whipsaws\u0026rdquo; during sideways movement. SMA Crossover (The Dual-Window Filter)\nThis variant uses two SMAs: a \u0026ldquo;Fast\u0026rdquo; (short-term) and a \u0026ldquo;Slow\u0026rdquo; (long-term).\nThe Signal: We buy when the Fast SMA crosses above the Slow SMA (a Golden Cross) and sell when it falls below. The Goal: By using a second average as a filter, we aim to ignore minor price noise and capture the \u0026ldquo;meat\u0026rdquo; of a larger trend. RSI (The Momentum Gauge)\nThe Relative Strength Index (RSI) measures the speed and change of price movements, ranging from 0 to 100.\nThe Signal: We buy when RSI recovers from an \u0026ldquo;oversold\u0026rdquo; state (below 30) and sell when it retreats from an \u0026ldquo;overbought\u0026rdquo; state (above 70). The Goal: To identify exhausted price moves and profit from mean reversion or momentum shifts. Bollinger Bands (The Volatility Envelope)\nBollinger Bands track volatility by placing bands at a set number of standard deviations away from a moving average. -The Signal: We buy when the price drops below the lower band (oversold) and sell when it breaches the upper band (overbought).\nThe Signal: We buy when the price drops below the lower band (oversold) and sell when it breaches the upper band (overbought). The Goal: To trade the \u0026ldquo;rebound\u0026rdquo; when prices reach extreme statistical dispersals. MACD (The Momentum Oscillator)\nThe Moving Average Convergence Divergence (MACD) tracks the relationship between two exponential moving averages.\nThe Signal: We buy when the MACD line crosses above its Signal line (the zero-crossover of the histogram). The Goal: To catch momentum shifts faster than simple SMAs. While responsive, it can produce false breakouts during high-volatility periods. MACD-V (The Volatility-Normalised Hybrid)\nAuthored by Alex Spiroglou, MACD-V normalises the MACD line by dividing it by the Average True Range (ATR).\nThe Signal: It uses fixed \u0026ldquo;strength thresholds\u0026rdquo; (±50). We trade only when the momentum is within specific zones. The Goal: To transform raw momentum into \u0026ldquo;relative momentum,\u0026rdquo; making the indicator more robust across different volatility regimes. MACD-V Dynamic (The Adaptive Strategy)\nThis is an evolution of the MACD-V that replaces fixed thresholds with adaptive ones based on rolling quantiles.\nThe Signal: Signals are only executed if the current momentum is in the top 20% of recent histogram values. The Goal: To filter out low-conviction signals and only enter trades when the market exhibits historically significant strength. Tuning the Machine: The Parameters # An algorithm is only as good as its settings. In our backtesting engine, we don\u0026rsquo;t just test the logic; we test the parameters that define the strategy\u0026rsquo;s \u0026ldquo;personality\u0026rdquo;.\nA strategy with a \u0026ldquo;short\u0026rdquo; lookback period is aggressive and twitchy - it catches moves early but gets fooled by noise. A \u0026ldquo;long\u0026rdquo; lookback is conservative and smooth - it stays in trends longer but reacts slowly to sudden crashes.\nFor this project, we explored a massive parameter grid:\nLookback Periods: Ranging from short-term bursts (12–14 periods) to long-term foundations (250 periods for SMAs).\nThresholds: The RSI 30/70 bands and the MACD-V \u0026ldquo;Strength Threshold\u0026rdquo; of 50.\nStatistical Deviations: The standard deviation multiplier (usually 2.0) for Bollinger Bands.\nAdaptive Quantiles: In the Dynamic MACD-V, we utilise an 80% quantile over a 20-period rolling window to ensure we only act on the most significant momentum.\nStop Losses: Every algorithm is being tested with no stop loss, and also with the following: 2%, 5%, 10% and 20%.\nFinding the \u0026ldquo;Goldilocks\u0026rdquo; zone - where the parameters are sensitive enough to profit but robust enough to survive - is the primary goal of this entire simulation.\nTechnical Challenge: The Memory Wall # When running 185,000+ backtest permutations (Strategies x Parameters x Windows), R users often hit a \u0026ldquo;Memory Wall\u0026rdquo;. Storing every trade and equity curve for every simulation can easily exceed 64GB of RAM.\nTo solve this, I implemented a \u0026ldquo;Chunked Parallel\u0026rdquo; architecture. We process one stop-loss setting at a time, parallelise the backtests within that chunk, summarise the results into tiny performance metrics, and then aggressively clear the memory.\nExample:\n# The \u0026#39;Memory-Safe\u0026#39; Loop Pattern for (sl in stop_losses) { message(\u0026#34;Starting Monte Carlo for Stop Loss: \u0026#34;, sl * 100, \u0026#34;%\u0026#34;) # 1. Parallel execution of backtests for this specific chunk results_chunk \u0026lt;- future_pmap(mc_param_grid_sl, backtest_worker_function) # 2. Extract metrics (reduces data size by 99%) summary_chunk \u0026lt;- get_performance_metrics(results_chunk, initial_equity = 1000) # 3. Store the small summary and PURGE the large results object all_summaries[[paste0(\u0026#34;SL\u0026#34;, sl)]] \u0026lt;- summary_chunk # CRITICAL: Clear the massive result list and call garbage collector rm(results_chunk) gc(verbose = FALSE) } Measuring Success: The CAPS Score # Total return (CAGR) is a \u0026ldquo;vanity metric\u0026rdquo;. If a strategy makes 100% return but has an 80% drawdown, most traders will quit long before they see the profit.\nTo find the truly \u0026ldquo;robust\u0026rdquo; strategy, I developed the Calmar-adjusted Probability Score (CAPS). It is a weighted average of:\nGeometric Mean CAGR: How much we actually make.\nWin Rate (by Window): How often the strategy is profitable across different time periods.\nMedian Sharpe Ratio: Risk-adjusted consistency.\nCVaR Drawdown: The \u0026ldquo;Tail Risk\u0026rdquo; (the average of the worst-case drawdowns).\nThe purpose of this metric is to penalise high risk, high reward strategies (like Buy \u0026amp; Hold) and, at the same time, reward strategies that effectively manage downside risk and maintain consistency.\nVisualising the Efficient Frontier # By plotting our Tail Risk against our Return, we can see the \u0026ldquo;Efficient Frontier\u0026rdquo;. We are ideally looking for strategies in the top-left corner: high returns with low tail risk.\nHowever, a word of realism: In practice, it is incredibly rare to find a strategy that sits comfortably in that top-left corner. Finance is a game of trade-offs; usually, the strategies with the highest returns come with a \u0026ldquo;stinging\u0026rdquo; tail risk, while the safest strategies often barely beat the bank\u0026rsquo;s interest rate. Our goal isn\u0026rsquo;t necessarily to find a \u0026ldquo;magic bullet,\u0026rdquo; but to find the strategy that pushes the boundary of what is statistically possible.\nTo make the chart more intuitive, we map the point size to the CAPS Score - the bigger the bubble, the more robust the strategy.\nHere is the output for the top 5 (by CAPS) algorithms:\nstrategy_type stop_loss geo_mean_CAGR win_rate_windows median_Sharpe cvar_drawdown n_samples robust_calmar prob_score CAPS sma_cross 0.10 0.6220032 0.971 0.99870 0.657136 1000 0.9465364 0.9697377 0.9178921 macd 0.00 0.5591531 0.978 0.93535 0.561100 1000 0.9965303 0.9147723 0.9115983 macd 0.15 0.5458585 0.975 0.92975 0.561100 1000 0.9728364 0.9065062 0.8818823 macd 0.05 0.5062554 0.981 0.93435 0.539100 1000 0.9390752 0.9165974 0.8607538 buy_hold 0.00 0.7889268 0.979 0.85025 0.823200 1000 0.9583659 0.8323947 0.7977387 macd 0.02 0.4829502 0.988 0.94685 0.569642 1000 0.8478136 0.9354878 0.7931192 Based on the table above, we can conclude SMA Crossover with a 10% stop loss is the most suitable strategy that is consistent, and manages both risk and return well.\nYou may find the entire backtesting code here.\nWhat\u0026rsquo;s Next? # We now have a trading strategy.\nIn Part 2, we will dive into creating a trading bot: moving from historical data to live trading data.\nStay tuned - the maths is done, now it is time to build the machine.\n","date":"19 December 2025","externalUrl":null,"permalink":"/posts/2025-12-19-building-an-automated-crypto-trader-part-1-survival-of-the-fittest-backtesting/","section":"Posts","summary":"","title":"Building an Automated Crypto Trader Part 1: Survival of the Fittest (Backtesting)","type":"posts"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/categories/deep-dives/","section":"Categories","summary":"","title":"Deep Dives","type":"categories"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/efficient-frontier/","section":"Tags","summary":"","title":"Efficient Frontier","type":"tags"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/monte-carlo/","section":"Tags","summary":"","title":"Monte Carlo","type":"tags"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/performance-metrics/","section":"Tags","summary":"","title":"Performance Metrics","type":"tags"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/r/","section":"Tags","summary":"","title":"R","type":"tags"},{"content":"","date":"19 December 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Introduction # This privacy policy describes how your personal information is collected, used, and shared when you visit https://sactyr.github.io/.\nCookies and Web Beacons # We use cookies to store information about visitors\u0026rsquo; preferences and to record user-specific information on which pages the user accesses or visits.\nGoogle AdSense # Third-party vendors, including Google, use cookies to serve ads based on a user\u0026rsquo;s prior visits to your website or other websites. Google\u0026rsquo;s use of advertising cookies enables it and its partners to serve ads to your users based on their visit to your sites and/or other sites on the Internet. Users may opt out of personalized advertising by visiting Ads Settings. Contact # If you have any questions, contact me via LinkedIn\n","date":"18 December 2025","externalUrl":null,"permalink":"/privacy/","section":"","summary":"","title":"Privacy Policy","type":"page"},{"content":" First post # Hello World. EOM.\n","date":"17 November 2025","externalUrl":null,"permalink":"/posts/2025-11-17_hello_world/","section":"Posts","summary":"","title":"Hello World.","type":"posts"},{"content":"","date":"17 November 2025","externalUrl":null,"permalink":"/categories/shorts/","section":"Categories","summary":"","title":"Shorts","type":"categories"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"Below is a list of my active public repositories, pulled directly from my GitHub profile using GitHub Actions.\nsactyr.github.io December 2025 sactyr/sactyr.github.io Personal Blog, made with Hugo \u0026amp; Blowfish HTML 0 0 crypto_trading December 2025 sactyr/crypto_trading Fully automated crypto trading bot in R R 0 0 noise_generator May 2025 sactyr/noise_generator Generate white and pink noise programatically R 0 0 ","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]